<div style="text-align: left;">
    <h3>The Software Development life-cycle</h3>
    <p>
        Every Software has a life-cycle. There are many ways of
        applying this life-cycle, but today will focus on the process
        used to create softwares. The phases ever
        software goes (sometimes, should) to be ready and delivered.
    </p>
    <p>
        The software development process is broken into a few
        phases: Anaylis, desing, implementation, testing and deploy.
        If you are not familiar with this cycle, here goes an example.
        Imagine you are creating a portfolio website for a body piercing/tattoo
        shop. Before actually coding anything you need to know what
        the website must or not have as a content, the sections and so on.
        The you make diagrams that represents the solutions, stuff the software
        will do like sending emails let's say. You also create the frontend
        prototype. After that you implement (code), test the webiste 
        and host it using a hosting provider and creates a DNS.
    </p>
    <p>
        I've just described the entire software life-cycle. The software's
        development process starts with <strong>problems</strong> and ends
        with a software solution.
        <br>
        Of course
        that depending on how complex the entire software is the overall
        cycle may or may not have more details. This was an example of
        a simple portfolio website.
    </p>
    <img src="" alt="Software Life Cycle image">
    <p>
        That being said, using the <strong>watterfall</strong> approach
        (an approach for the software development process),
        these phases are accomplished one
        after the other.
        Each phase has an important role on this life-cycle.
        Each one of them will be input for the next one.
        <br>
        This means that first we do the analysis
        and have a well and abstract description of the requirements,
        then and only then we create the designs that represents
        the solutions based on the requirements for the software.
        Then we move on to the coding phase, then we test and deploy.
    </p>
    <h4>Analysis</h4>
    <p>
        The overall objective of any analysis activity on this life-cycle
        is to create a model of the requirements that is independent
        of implementation rules. In other words, first what
        the software must have and how it must function is documented using tools
        and languages that are agnostic to the implementation rules, such as
        programming languages, infrastructure constraints and so on.
    </p>
    <p>
        In short, the output of this phase can be ER Models and flow-charts,
        use cases diagrams, requirements list and so on.
    </p>
    <h4>Desing</h4>
    <p>
        With the analysis's output, the overall architecture of the software
        is created. The desing creates a solution based on the 
        requirements that later will be translated into a softare.
        The results can be a low-level architecture, meaning that the desinger
        created a solution that is on a component level or algorithm level.
        <br>
        Or it can also be a high-level architecture. A macro representation
        of what the software has.
    </p>
    <h4>Coding or Implementation</h4>
    <p>
        The implementation phase is very simple. The desing is translated into
        actual code.
    </p>
    <h4>Testing</h4>
    <p>
        After implemented, I mean, after translating the high/low architectures
        into code, the software must be tested. On this phase the software's
        features are tested to guarantee that they are working properly according
        with the requirements.
    </p>
    <h4>Deploy</h4>
    <p>
        Once the software is tested, finally but not least important,
        the deploy phase must be acchived so that the user can
        actually use it.
    </p>
    <p>
        Now that's a very summarized description of these phases.
        They can be way more complex...
    </p>
    <h3>Object Oriented Software Development Process</h3>
    <h3>What Object-oriented desing is?</h3>
    <p>
        An object-riented desing is the process of defining objects and
        their interactions with the purpose of solving a software problem.
        The result is a system of interacting objects,
        also knwon as <strong>object-oriented program</strong>.
    </p>
    <p>
        An object is an entity composed by data and behaviors
        (the methods/functions/procedures).
        The procedures act upon the object's data, manipulating them,
        changing the object's
        state or retrieving information about it. The interfaces
        (the public methods) are how the object can be interacted with.
        The overall objective is that the object represents a single
        concern within the system/application/program and interact with
        your own data.
    </p>
    <p>
        Object-oriented desing is the process of identifying the
        objects (their data, interfaces and implemetations)
        and how they interact with each other to solve one or more problems. 
        It is an approach to Software Desing. The process of desiging software
        solutions.
        The solution can be low-level (component or algorithm)
        or high-level (architecture).
    </p>
    <h3>Object-oriented analysis</h3>
    <p>
        To understand object-oriented design, first we have to
        understand what information we need for using this process.
        The input for this process is achieved in the OOA (Object-oriented
        analysis), an approach for identifying and documenting
        problems. In other words, the object-oriented design will
        represent a object-oriented program that will solve one or
        more problems that were indetified and documented during the OOA.
    </p>
    <p>
        Every application/system has a life cycle. I would go even further
        and say that today every thing you create within the
        application/system has a life cycle.
        Why? Simple, today you don't develop an entirie application/system
        from the ground up. You create it in small pieces.
        This model is also called <strong>incremental mode</strong>.
        But that's a subject for another post...
    </p>
    <p>
        There are many other software life-cycle models in which
        the phases are accomplished in different ways. This subject
        deservers an entire article or series of articles.
        <br>
        In short, the Object-oriented analysis falls into
        the analisys phase and the outputs are diagrams.
        In this approach the requirements are organized in objects
        and, if you read <a href="#" target="blank">this article</a>
        you know that objects are composed by data and behaviors to
        represent entities into the application/system. So naturally
        these two aspects are dealt with together instead of separately,
        like in other software analysis approaches.
    </p>
    <h3></h3>
    <h4>Problems identification</h4>
    <h3>Functional and Non Functional Requirements</h3>
    <h3>Procedural oriented analysis</h3>
    <h3>Object-oriented desing vs TDD and agile</h3>
    Good Luck XD
</div>